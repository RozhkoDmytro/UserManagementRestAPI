package services

import (
	"context"
	"strconv"
	"time"

	"gitlab.com/jkozhemiaka/web-layout/internal/apperrors"
	"gitlab.com/jkozhemiaka/web-layout/internal/constants"
	"gitlab.com/jkozhemiaka/web-layout/internal/repositories"
	"gorm.io/gorm"

	"gitlab.com/jkozhemiaka/web-layout/internal/models"
	"go.uber.org/zap"
)

type UserService struct {
	userRepo repositories.UserRepoInterface
	logger   *zap.SugaredLogger
}

type UserServiceInterface interface {
	CreateUser(ctx context.Context, user *models.User) (string, error)
	DeleteUser(ctx context.Context, userID string) (*models.User, error)
	GetUser(ctx context.Context, userID string) (*models.User, error)
	UpdateUser(ctx context.Context, userID string, user *models.User) (*models.User, error)
	ListUsers(ctx context.Context, page, pageSize int) ([]models.User, error)
	CountUsers(ctx context.Context) (int, error)
	GetUserByEmail(ctx context.Context, email string) (*models.User, error)
	Vote(ctx context.Context, vote *models.Vote) (string, error)
	RevokeVote(ctx context.Context, userID uint, profileID uint) error
}

func NewUserService(userRepo repositories.UserRepoInterface, logger *zap.SugaredLogger) UserServiceInterface {
	return &UserService{
		userRepo: userRepo,
		logger:   logger,
	}
}

func (service *UserService) CreateUser(ctx context.Context, user *models.User) (userId string, err error) {
	insertedUser, err := service.userRepo.CreateUser(ctx, user)
	if err != nil {
		service.logger.Error(err)
		return constants.EmptyString, err
	}

	return strconv.Itoa(int(insertedUser.ID)), nil
}

func (service *UserService) GetUser(ctx context.Context, userID string) (user *models.User, err error) {
	user, err = service.userRepo.GetUser(ctx, userID)
	if err != nil {
		service.logger.Error(err)
		return nil, err
	}

	return user, nil
}

func (service *UserService) DeleteUser(ctx context.Context, userID string) (user *models.User, err error) {
	user, err = service.userRepo.DeleteUser(ctx, userID)
	if err != nil {
		service.logger.Error(err)
		return nil, err
	}

	return user, nil
}

func (service *UserService) UpdateUser(ctx context.Context, userID string, updatedData *models.User) (user *models.User, err error) {
	user, err = service.userRepo.UpdateUser(ctx, userID, updatedData)
	if err != nil {
		service.logger.Error(err)
		return nil, err
	}

	return user, nil
}

func (service *UserService) ListUsers(ctx context.Context, page, pageSize int) (user []models.User, err error) {
	user, err = service.userRepo.ListUsers(ctx, page, pageSize)
	if err != nil {
		service.logger.Error(err)
		return nil, err
	}

	return user, nil
}

func (service *UserService) CountUsers(ctx context.Context) (int, error) {
	count, err := service.userRepo.CountUsers(ctx)
	if err != nil {
		service.logger.Error(err)
		return 0, err
	}

	return count, nil
}

func (service *UserService) GetUserByEmail(ctx context.Context, email string) (*models.User, error) {
	user, err := service.userRepo.GetUserByEmail(ctx, email)
	if err != nil {
		service.logger.Error(err)
		return nil, err
	}

	return user, nil
}

func (service *UserService) Vote(ctx context.Context, vote *models.Vote) (string, error) {
	// Get the user profile
	var user models.User
	err := service.userRepo.GetUserByID(ctx, vote.UserID, &user)
	if err != nil {
		service.logger.Error("Failed to get user", zap.Error(err))
		return constants.EmptyString, apperrors.InsertionFailedErr.AppendMessage(err.Error())
	}

	// Check if the user has voted within the last hour
	if time.Since(user.UpdatedAt) < time.Hour {
		return constants.EmptyString, apperrors.VoteCooldownErr.AppendMessage("You can only vote once per hour.")
	}

	// Check if the user has already voted for this profile
	existingVote, err := service.userRepo.GetVote(ctx, vote.UserID, vote.ProfileID)
	if err != nil && err != gorm.ErrRecordNotFound {
		service.logger.Error("Failed to check existing vote", zap.Error(err))
		return constants.EmptyString, apperrors.InsertionFailedErr.AppendMessage(err.Error())
	}

	if existingVote != nil {
		// Update existing vote
		existingVote.Value = vote.Value
		err = service.userRepo.UpdateVote(ctx, existingVote)
		if err != nil {
			service.logger.Error("Failed to update vote", zap.Error(err))
			return constants.EmptyString, apperrors.UpdateFailedErr.AppendMessage(err.Error())
		}
		return strconv.Itoa(int(existingVote.ID)), nil
	}

	// Create new vote
	insertedVote, err := service.userRepo.CreateVote(ctx, vote)
	if err != nil {
		service.logger.Error("Failed to create vote", zap.Error(err))
		return constants.EmptyString, apperrors.InsertionFailedErr.AppendMessage(err.Error())
	}

	return strconv.Itoa(int(insertedVote.ID)), nil
}

func (service *UserService) RevokeVote(ctx context.Context, userID uint, profileID uint) error {
	// Proceed to delete the vote
	err := service.userRepo.DeleteVote(ctx, userID, profileID)
	if err != nil {
		return err
	}

	return nil
}
